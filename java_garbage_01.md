---
title: 垃圾收集器 - 回收算法
---

##### 引用计数

引用计数难以解决对象之间相互循环引用的问题

##### 可达性分析

可达性分析基本思路是 通过一系列的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连时，则该对象时不可用的。

> GC Roots:

1. 虚拟机栈中引用的对象(栈帧中的本地变量表)
2. 方法区中类静态属性引用的对象
3. 方法区中常用引用的对象
4. 本地方法栈中JNI引用的对象

> 引用

JDK1.2之后，Java对引用的概念进行了扩充： 
1. 强引用 - 只要强引用存在，垃圾收集器永远不会回收掉被引用的对象
2. 软引用 - 系统将要发生内存溢出异常之前，该类对象列进回收范围进行第二次回收，如果本次回收仍不满足
           内存需求，则抛出内存溢出异常
3. 弱引用 - 无论内存是否够用，关联软引用的对象都会被垃圾收集器回收掉
4. 虚引用 - 虚引用的存在不会影响对象的存活时间，其唯一目的就是能在这个对象被收集器回收时收到一个
           系统通知

***宣告对象的死亡至少要经历两次标记过程***

> 方法区回收
在Java虚拟机规范中要求可以不在方法去实现垃圾回收。
在方法区进行垃圾收集的“性价比”一般比较低，在堆中，尤其是在新生代中，常规应用进行一次垃圾收集一般可以回收70~95%的控件，永久代的回收效率远低于此，其回收内容包括两部分：废弃常量和无用的类。

1. 无用的类判定：
该类所有的实例都已经被回收，也就是Java堆中不存在该类的任何实例；
加载该类的ClassLoader已经被回收
该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法

##### 垃圾收集算法

###### 标记-清除

首先标记出所有需要回收的对象，在标记完成后统一回收所有的标记对象

###### 复制

将内存按容量划分为大小相等的两块，每次只使用其中的一块，当这一块的内存用完了，就将还存活的对象复制到另一块上面，然后把使用过的空间一次性清理

###### 标记-整理

标记出所有需要回收的对象，然后让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存

###### 分代收集

把Java堆分为新生代和老年代，这样可以根据各个年代的特点采用最适当的收集算法。
新生代 -> 复制
老年代 -> 标记-清理 或 标记-整理

> GC停顿

可达性分析必须在一个能确保一致性的快照中进行，此处的“一致性”是指在整个分析期间整个执行系统看起来就像是被冻结在某个时间点上，不可以出现分析过程中对象的引用关系还在不断变化，如果该点不在满足的话分析结果准确性就无法得到保证。
***Sun将这件事情称为Stop The World***

