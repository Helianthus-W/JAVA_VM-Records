---
title: 垃圾收集器 - 回收算法
---

##### 引用计数

引用计数难以解决对象之间相互循环引用的问题

##### 可达性分析

可达性分析基本思路是 通过一系列的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连时，则该对象时不可用的。

> GC Roots:

1. 虚拟机栈中引用的对象(栈帧中的本地变量表)
2. 方法区中类静态属性引用的对象
3. 方法区中常用引用的对象
4. 本地方法栈中JNI引用的对象

> 引用

JDK1.2之后，Java对引用的概念进行了扩充： 
1. 强引用 - 只要强引用存在，垃圾收集器永远不会回收掉被引用的对象
2. 软引用 - 系统将要发生内存溢出异常之前，该类对象列进回收范围进行第二次回收，如果本次回收仍不满足
           内存需求，则抛出内存溢出异常
3. 弱引用 - 无论内存是否够用，关联软引用的对象都会被垃圾收集器回收掉
4. 虚引用 - 虚引用的存在不会影响对象的存活时间，其唯一目的就是能在这个对象被收集器回收时收到一个
           系统通知

***宣告对象的死亡至少要经历两次标记过程***

> 方法区回收
在Java虚拟机规范中要求可以不在方法去实现垃圾回收。
在方法区进行垃圾收集的“性价比”一般比较低，在堆中，尤其是在新生代中，常规应用进行一次垃圾收集一般可以回收70~95%的控件，永久代的回收效率远低于此，其回收内容包括两部分：废弃常量和无用的类。

1. 无用的类判定：
该类所有的实例都已经被回收，也就是Java堆中不存在该类的任何实例；
加载该类的ClassLoader已经被回收
该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法

##### 垃圾收集算法

###### 标记-清除

首先标记出所有需要回收的对象，在标记完成后统一回收所有的标记对象

###### 复制

将内存按容量划分为大小相等的两块，每次只使用其中的一块，当这一块的内存用完了，就将还存活的对象复制到另一块上面，然后把使用过的空间一次性清理

###### 标记-整理

标记出所有需要回收的对象，然后让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存

###### 分代收集

把Java堆分为新生代和老年代，这样可以根据各个年代的特点采用最适当的收集算法。
新生代 -> 复制
老年代 -> 标记-清理 或 标记-整理

##### HotSpot的算法实现

###### 枚举根节点

HotSpot使用OopMap的数据结构来存放对象的引用。在类加载完的时候，HotSpot就把对象内什么偏移量上是什么类型的数据计算出来，在JIT编译过程中，也会在特定的位置记录下栈和寄存器中哪些位置是引用。

> GC停顿

可达性分析必须在一个能确保一致性的快照中进行，此处的“一致性”是指在整个分析期间整个执行系统看起来就像是被冻结在某个时间点上，不可以出现分析过程中对象的引用关系还在不断变化，如果该点不在满足的话分析结果准确性就无法得到保证。

***Sun将这件事情称为Stop The World***

###### 安全点

安全点的选定基本上是以程序“是否具有让程序长时间执行的特征”为标准。

> GC发生时如何让所有的线程(不包括执行JNI调用的线程)都跑到最近的安全点上在停顿下来

1. 抢先式中断(Preemptive Suspension)
不需要线程的执行代码主动配合，在GC发生时，首先把所有的线程全部中断，如果发现有线程中断的地方不在安全点上，就恢复线程，让它跑到安全点上。

2. 主动式中断(Voluntary Suspension)
需要线程的执行代码去配合但不直接对线程操作，仅需要设定一个标志，各个线程执行时主动去轮询这个标志。发现中断标志为真时就自己中断挂起。

[注] 轮询标志： 安全点位置  内存分配指令位置

###### 安全区

当线程处于Sleep状态或者Blocked状态时，此时线程无法响应JVM的中断请求，即无法到达安全的地方去中断挂起。此时就需要使用安全区来解决。

***安全区： 引用关系不会发生变化的一段代码片段***，该区域内任意位置发生GC都是安全的。

##### 垃圾收集器

通常虚拟机中往往不止有一种GC收集器。

###### Serial收集器

Serial收集器是一个单线程的收集器。在进行垃圾收集时，必须暂停其他所有的工作线程。直到它收集结束。对于运行在client模式下的虚拟机来说是一个很好的选择。

###### ParNew收集器

