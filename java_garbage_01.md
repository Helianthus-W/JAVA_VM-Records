---
title: 垃圾收集器 - 回收算法
---

##### 引用计数

引用计数难以解决对象之间相互循环引用的问题

##### 可达性分析

可达性分析基本思路是 通过一系列的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连时，则该对象时不可用的。

> GC Roots:

1. 虚拟机栈中引用的对象(栈帧中的本地变量表)
2. 方法区中类静态属性引用的对象
3. 方法区中常用引用的对象
4. 本地方法栈中JNI引用的对象

> 引用

JDK1.2之后，Java对引用的概念进行了扩充： 
1. 强引用 - 只要强引用存在，垃圾收集器永远不会回收掉被引用的对象
2. 软引用 - 系统将要发生内存溢出异常之前，该类对象列进回收范围进行第二次回收，如果本次回收仍不满足
           内存需求，则抛出内存溢出异常
3. 弱引用 - 无论内存是否够用，关联软引用的对象都会被垃圾收集器回收掉
4. 虚引用 - 虚引用的存在不会影响对象的存活时间，其唯一目的就是能在这个对象被收集器回收时收到一个
           系统通知

***宣告对象的死亡至少要经历两次标记过程***

> 方法区回收
在Java虚拟机规范中要求可以不在方法去实现垃圾回收。
在方法区进行垃圾收集的“性价比”一般比较低，在堆中，尤其是在新生代中，常规应用进行一次垃圾收集一般可以回收70~95%的控件，永久代的回收效率远低于此，其回收内容包括两部分：废弃常量和无用的类。

1. 无用的类判定：
该类所有的实例都已经被回收，也就是Java堆中不存在该类的任何实例；
加载该类的ClassLoader已经被回收
该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法

##### 垃圾收集算法

###### 标记-清除

首先标记出所有需要回收的对象，在标记完成后统一回收所有的标记对象

###### 复制

将内存按容量划分为大小相等的两块，每次只使用其中的一块，当这一块的内存用完了，就将还存活的对象复制到另一块上面，然后把使用过的空间一次性清理

###### 标记-整理

标记出所有需要回收的对象，然后让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存

###### 分代收集

把Java堆分为新生代和老年代，这样可以根据各个年代的特点采用最适当的收集算法。
新生代 -> 复制
老年代 -> 标记-清理 或 标记-整理

##### HotSpot的算法实现

###### 枚举根节点

HotSpot使用OopMap的数据结构来存放对象的引用。在类加载完的时候，HotSpot就把对象内什么偏移量上是什么类型的数据计算出来，在JIT编译过程中，也会在特定的位置记录下栈和寄存器中哪些位置是引用。

> GC停顿

可达性分析必须在一个能确保一致性的快照中进行，此处的“一致性”是指在整个分析期间整个执行系统看起来就像是被冻结在某个时间点上，不可以出现分析过程中对象的引用关系还在不断变化，如果该点不在满足的话分析结果准确性就无法得到保证。

***Sun将这件事情称为Stop The World***

###### 安全点

安全点的选定基本上是以程序“是否具有让程序长时间执行的特征”为标准。

> GC发生时如何让所有的线程(不包括执行JNI调用的线程)都跑到最近的安全点上在停顿下来

1. 抢先式中断(Preemptive Suspension)
不需要线程的执行代码主动配合，在GC发生时，首先把所有的线程全部中断，如果发现有线程中断的地方不在安全点上，就恢复线程，让它跑到安全点上。

2. 主动式中断(Voluntary Suspension)
需要线程的执行代码去配合但不直接对线程操作，仅需要设定一个标志，各个线程执行时主动去轮询这个标志。发现中断标志为真时就自己中断挂起。

[注] 轮询标志： 安全点位置  内存分配指令位置

###### 安全区

当线程处于Sleep状态或者Blocked状态时，此时线程无法响应JVM的中断请求，即无法到达安全的地方去中断挂起。此时就需要使用安全区来解决。

***安全区： 引用关系不会发生变化的一段代码片段***，该区域内任意位置发生GC都是安全的。

##### 垃圾收集器

通常虚拟机中往往不止有一种GC收集器。

###### Serial收集器

Serial收集器是一个单线程的收集器。在进行垃圾收集时，必须暂停其他所有的工作线程。直到它收集结束。对于运行在client模式下的虚拟机来说是一个很好的选择。

###### ParNew收集器

ParNew收集器是Serial收集器的多线程版本。对于运行在Server模式下的虚拟机中首选的新生代收集器。默认开启的收集线程数与CPU的数量相同。

> 并行(Parallel)
指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态

> 并发
指用户线程和垃圾收集线程同时执行工作(但并不一定是并行的，可能会交替执行)，用于程序在继续运行，而垃圾收集程序运行与另一个CPU上。

###### Parallel Scavenge收集器
Parallel Scavenge收集器是一个新生代收集器，使用的是复制算法，也是并行的多线程收集器。它的关注点在于达到一个可控制的吞吐量

> 吞吐量
所谓吞吐量是CPU运行用户代码的时间与CPU总消耗时间的比值(吞吐量 = 运行用户代码时间 / (运行用户代码时间 + 垃圾收集时间))。

> GC自适应调节策略
虚拟机根据当前系统的运行情况收集性能监控信息，有虚拟机自己来指定新生代的大小，Eden和Survivor区的比例。晋升老年代对象的大小等细节参数。

###### Serial Old收集器
Serial Old是Serial收集器的老年代版本，他也是一个单线程收集器，使用“标记-整理”算法。

###### Parallel Old收集器
Parallel Old是Parallel Scavenge收集器的老年代版本，使用多线程和“标记-整理”算法。在重视吞吐量以及CPU资源敏感的场合，都可以考虑Parallel Scavenge和Parallel Old收集器。

###### CMS收集器  -  Concurrent Mark Sweep
CMS收集器是一种以获取最短回收停顿时间为目标的垃圾收集器，使用“标记-清除”算法，符合大部分B/S结构的服务端应用的需求(重视响应速度，停顿时间短)。

1. 初始标记(需要GC停顿)
2. 并发标记
3. 重新标记(需要GC停顿)
4. 并发清除

> 优点： 
并发收集、低停顿

> 缺点：
1. CMS收集器对CPU资源非常敏感
2. CMS收集器无法收集浮动垃圾
3. 由于CMS收集器采用的“标记-清除”算法。也就意味着回收结束时会产生大量的碎片空间。

> 增量式并发收集器(i-CMS)
在并发标记、清理的时候采用让GC线程和用户线程交替的方式运行，尽量减少GC线程独占资源的时间。

> 浮动垃圾
CMS收集器并发清理垃圾的同时用户线程仍在继续运行，CMS无法清理本次用户线程新产生的垃圾，只能下次GC时才能回收掉这部分垃圾 - 浮动垃圾。

[注] CMS不会等到老年代完全填满时才开始工作，需要预留一部分空间提供并发收集时的程序运行。若CMS运行期间预留的内存无法满足程序需要时，则会出现“Concurrent Mode Failure”失败。此时虚拟机会临时启用Serial Old收集器重新进行老年代收集。

CMS工作结束会产生大量的碎片空间，因此当发生老年代空间过剩，但虚拟机无法找到足够大的连续空间为当前对象分配时，会触发FULL GC。CMS为此提供可配置的内存整理启用开关。

###### G1收集器  -  Garbage First
G1是面向服务端应用的垃圾收集器。

1. 初始标记(GC停顿)
2. 并发标记
3. 最终标记(GC停顿)
4. 筛选回收(GC停顿)

> 优点： 
1. 并行与并发
2. 分代收集
3. 空间整合
4. 可预测的停顿

G1收集器时代，Java堆的内存布局就与其他垃圾收集器有很大区别。它将整个堆划分为多个大小相等的独立区域，虽然保留有新生代和老年代的概念，但新生代和老年代都是一部分独立区域的集合，不再是物理隔离。

G1跟踪各个Region里面的垃圾堆的价值大小(回收所获得的空间大小以及回收所需时间的经验值)，在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region。


##### 内存分配规则

1. 对象优先在Eden分配

2. 大对象直接进入老年代 (-XX:PretenureSizeThreshold)

3. 长期存活对象进入老年代

4. 动态对象年龄判断

5. 空间分配担保

